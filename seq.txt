fig = plt.figure(figsize=(6, 6))
ax = fig.add_axes([0, 0, 1, 1])
ax.set_aspect('equal', 'box')



radio = 1
sepp = 0
ancho = 10
tam = 3
Espacio = 2

W = tam * len(origenes)
Q = (Espacio * len(origenes)) - Espacio
sour_inicial = 360 - ((W + Q)/ 2)
"""
Nodos de Sources
"""
nodos_ori_0 = {}
dif0 = 360 - ((W + Q)/ 2)
dif1 = dif0 # inicio de los nodos


for o in origenes:
    teta1 = dif0
    teta2 = dif0+tam
    
    sour, mitad3, etiquetapos = source1(radio = radio, theta1 = teta1, theta2 = teta2,
                                             width = ancho, sep = sepp, color = origenes_colors[o])
    ax.add_patch(sour)
    central_angle = (((dif0+tam)-dif0)/2)+dif0
    ax.text(etiquetapos[0]*1.15, etiquetapos[1]*1.15, o, color = 'black', va = 'center', ha = 'center', 
            fontsize = 8, rotation = central_angle, family = 'monospace')
    #ax.scatter(etiquetapos[0], etiquetapos[1], s = 20, c = 'black', zorder = 2)
    
    if Counts_SOURCE[o] == 1:
        t1 = dif1
        t2 = dif1+tam
        sour2, mitad33, internopos = source2(radio = radio, theta1 = t1, theta2 = t2,
                                             width = ancho, sep = sepp, color = 'white')
        ax.add_patch(sour2)
        nodos_ori_0[o] = [sour2, mitad33, internopos]
        dif1 += (tam+Espacio)
    else:
        t1 = dif1
        sectores = tam/Counts_SOURCE[o]
        ss0 = 0
        ss1 = sectores
        intersecciones_ori = []
        for r in range(Counts_SOURCE[o]):
            t1 = ss0+dif1
            t2 = ss1+dif1
            sour2, mitad33, internopos = source2(radio = radio, theta1 = t1, theta2 = t2,
                                                 width = ancho, sep = sepp, color = 'white')
            
            ax.add_patch(sour2)
            intersecciones_ori.append([sour2, mitad33, internopos])
            
            ss1 += sectores
            ss0 += sectores
        nodos_ori_0[o] = intersecciones_ori
        dif1 += (tam+Espacio)
        
    PER = 2
    central_angle = (((dif0+tam)-dif0)/2)+dif0
    
    dif0 += (tam+Espacio)

"""
Nodos de Targets
"""   
#----------
# angulo de separacion elegido

angulo_espacio = 7 

continuacion = dif0 - Espacio - 360
Espacio2 = 0.5

if angulo_espacio > 0:
    dif00 = angulo_espacio + continuacion
    tam2 = ((sour_inicial-angulo_espacio)-(continuacion+angulo_espacio) - ((len(destinos) * Espacio2)-Espacio2))/len(destinos)
else:
    tam2 = ((sour_inicial-continuacion) - ((len(destinos) * Espacio2)-Espacio2))/len(destinos)
    dif00 = continuacion
    

nodos_des_1 = {}
#dif00 = continuacion
dif11 = dif00
#tam2 = ((sour_inicial-continuacion) - ((len(destinos) * Espacio2)-Espacio2))/len(destinos)

radio2 = 1
sepp2 = 0.01
ancho2 = 7

for o in destinos:
    teta11 = dif11
    teta22 = dif11+tam2
    sour, mitad3, etiquetapos = source1(radio = radio2, theta1 = teta11, theta2 = teta22,
                                             width = ancho2, sep = sepp2, color = 'silver')
    ax.add_patch(sour)
    
    central_angle = (((dif00+tam2)-dif00)/2)+dif00
    ax.text(etiquetapos[0]*1.12, etiquetapos[1]*1.12, o, color = 'black', va = 'center', ha = 'center', 
            fontsize = 8, rotation = central_angle, family = 'monospace')
    #ax.scatter(etiquetapos[0], etiquetapos[1], s = 20, c = 'black', zorder = 2)
    if Counts_TARGET[o] == 1:
        t1 = dif11
        t2 = dif11+tam2
        sour2, mitad33, internopos = source2(radio = radio2, theta1 = t1, theta2 = t2,
                                             width = ancho2, sep = sepp2, color = 'white')
        ax.add_patch(sour2)
        nodos_des_1[o] = [sour2, mitad33, internopos]
        dif11 += (tam2+Espacio2)
    else:
        t1 = dif11
        sectores = tam2/Counts_TARGET[o]
        ss0 = 0
        ss1 = sectores
        intersecciones_des = []
        for r in range(Counts_TARGET[o]):
            t1 = ss0+dif11
            t2 = ss1+dif11
            sour2, mitad33, internopos = source2(radio = radio2, theta1 = t1, theta2 = t2,
                                                 width = ancho2, sep = sepp2, color = 'white')
            ax.add_patch(sour2)
            intersecciones_des.append([sour2, mitad33, internopos])
            ss1 += sectores
            ss0 += sectores
        nodos_des_1[o] = intersecciones_des
        dif11 += (tam2+Espacio2)
        
    central_angle2 = (((dif00+tam2)-dif00)/2)+dif00
    radian2 = (central_angle2*np.pi)/180
    x2 = (radio2 * (1-((ancho2/2)/100))) *  np.cos(radian2)
    y2 = (radio2 * (1-((ancho2/2)/100))) *  np.sin(radian2)
    ax.scatter(x2, y2, s = 10, c = 'black', zorder = 2)
    
    dif00 += (tam2+Espacio2)
    
"""
Conexiones
"""
#---------------
# parte 1
XX = []
for ori in origenes:
    xu = 0
    if Counts_SOURCE[ori] == 1:
        for SOURCE, TARGET in net:
            if ori == SOURCE:
                if Counts_TARGET[TARGET] == 1:  # target uno
                    #print('>>>', SOURCE, TARGET)
                    path_data = LOCATIONS(nodos_ori_0[SOURCE][1], nodos_des_1[TARGET][1])

                    codes, verts = zip(*path_data)
                    path = mpath.Path(verts, codes)
                    patch = mpatches.PathPatch(path, facecolor=origenes_colors[ori], alpha=1, lw = None, ec = 'none', zorder = 0)
                    ax.add_patch(patch)
                else: # target con mas de uno
                    XX.append([SOURCE, 'NA', TARGET])
    else:
        for SOURCE, TARGET in net:
            if ori == SOURCE:
                #print(SOURCE, xu, TARGET)
                if Counts_TARGET[TARGET] == 1:
                    #print(SOURCE, xu, TARGET, '----')
                    path_data = LOCATIONS(nodos_ori_0[SOURCE][xu][1], nodos_des_1[TARGET][1])

                    codes, verts = zip(*path_data)
                    path = mpath.Path(verts, codes)
                    patch = mpatches.PathPatch(path, facecolor=origenes_colors[ori], alpha=1, lw = None, ec = 'none', zorder = 0)
                    ax.add_patch(patch)
                else: # target con mas de uno
                    XX.append([SOURCE, xu, TARGET])
                xu += 1

#---------------
# Parte 2
output = []
for SOURCE, P, TARGET in XX:
    if TARGET not in output:
        output.append(TARGET)
            
for s in output:
    n = 0
    for SOURCE, P, TARGET in XX:
        if s == TARGET:
            if P == 'NA':
                path_data = LOCATIONS(nodos_ori_0[SOURCE][1], nodos_des_1[TARGET][n][1])

                codes, verts = zip(*path_data)
                path = mpath.Path(verts, codes)
                patch = mpatches.PathPatch(path, facecolor=origenes_colors[SOURCE], alpha=1, lw = None, ec = 'none', zorder = 0)
                ax.add_patch(patch)
            else:
                path_data = LOCATIONS(nodos_ori_0[SOURCE][P][1], nodos_des_1[TARGET][n][1])

                codes, verts = zip(*path_data)
                path = mpath.Path(verts, codes)
                patch = mpatches.PathPatch(path, facecolor=origenes_colors[SOURCE], alpha=1, lw = None, ec = 'none', zorder = 0)
                ax.add_patch(patch)
            n += 1 

ax.set_xlim(-1.1, 1.1)
ax.set_ylim(-1.1, 1.1)
ax.axis('off')

#plt.savefig('Circos_011.png', dpi = 900, bbox_inches= 'tight')

plt.show()
